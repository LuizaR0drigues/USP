#include "bregistro.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "registro.h"

#define LOTACAO_MAX 4

#define FOLHA '0'
#define FOLHA_N '1'
#define NULL_VALUE -2

#define TAMANHO_NO 93

int contador_RRN = 0; // vai ser substituido pelo cabecalho

//caso o ponteiro pi seja nulo = -1
//os ints inicializam com -1
NoArvore *no_criar(bool folha,int rrn)
{
    printf("Um novo no foi criado\n");
    NoArvore *no = malloc(sizeof(NoArvore));
    if(folha){
        no->folha = FOLHA; // é folha
    }else{
        no->folha = FOLHA_N; // não é folha
    }
    
    no->nroChavesIndexadas = -1;
    no->RRNdoNo = rrn;
    for(int i=0; i< ORDEM; i++)
    {
        no->P[i] = -1; //5 ponteiros
    }
    for(int i=0; i < ORDEM -1; i++)
    {
        no->CPRs[i].C = NULL_VALUE; //4 campos de referencia
        no->CPRs[i].PR = -1;
    }
    no->lotacao=0;
 return no;
}

NoArvore *no_readbin(FILE* entrada,int RRN) 
{
    fseek(entrada,TAMANHO_NO*RRN,SEEK_SET); //vai pro lugar certo
    NoArvore* aux = no_criar(true,-1);


    fread(&aux->folha, sizeof(char), 1, entrada);
    fread(&aux->nroChavesIndexadas, sizeof(int), 1, entrada);
    fread(&aux->RRNdoNo, sizeof(int), 1, entrada);
    for(int i =0; i<ORDEM-1; i++)
    {
        fread(&aux->CPRs[i].C, sizeof(int), 1, entrada);
        fread(&aux->CPRs[i].PR, sizeof(int), 1, entrada);
    }

    return aux;
}

void no_writebin(FILE *nomebin, NoArvore *no)
{
    fseek(nomebin, TAMANHO_NO*no->RRNdoNo,SEEK_SET);
    fwrite(&no->folha, sizeof(char), 1, nomebin);
    fwrite(&no->nroChavesIndexadas, sizeof(int), 1, nomebin);
    fwrite(&no->RRNdoNo, sizeof(int), 1, nomebin);
     for(int i =0; i<ORDEM-1; i++)
    {
        fwrite(&no->CPRs[i].C, sizeof(long int), 1, nomebin);
        fwrite(&no->CPRs[i].PR, sizeof(long int), 1, nomebin);
    }
    printf("Ok\n");
}


void no_print(NoArvore *no){
    printf("RRN=%d  |  P[0]=%d  ",no->RRNdoNo,no->P[0]);
    for(int i=0;i<LOTACAO_MAX;i++){
        printf("(%ld %d) P[%d]=%d  ",
            no->CPRs[i].C,no->CPRs[i].PR,
            i+1,no->P[i+1]);
    }
    printf("\n");
}

PCPR get_null_pcpr(){
    PCPR null_pcpr;
    CPR null_cpr;
    null_cpr.C=NULL_VALUE;
    null_cpr.PR=-1;
    null_pcpr.corpo=null_cpr;
    null_pcpr.P=-1;
    return null_pcpr;
}

PCPR no_tenta_inserir(NoArvore *no,CPR valor_inserir,FILE *arquivo){
    // Retorna o CPR que sair caso ele fique cheio
    PCPR overflow = get_null_pcpr();


    // Fazer a inserção binária aqui ao invés desse método aqui embaixo:
    int idx_inserir = 0;
    for(int i=0;i<no->lotacao;i++){ // descobre a posição para inserir
        if(valor_inserir.C > no->CPRs[i].C){
            idx_inserir = i+1;
        }
    }
    
    for(int i=no->lotacao - 1;i>=idx_inserir;i--){ // faz o shift
        if(i+1 == LOTACAO_MAX){
            overflow.P = no->P[i+1];
            overflow.corpo = no->CPRs[i];
        }else{
            no->CPRs[i+1] = no->CPRs[i];
            no->P[i+2] = no->P[i+1];
        }
        
    }
    no->CPRs[idx_inserir] = valor_inserir; // coloca o valor de fato
    no->lotacao++;

    // salva no arquivo as atualizações
    no_writebin(arquivo,no);

    return overflow; // avisa que inseriu de boas
}

bool PCPR_isnull(PCPR pcpr){
    return pcpr.corpo.C == NULL_VALUE;
}

void space(int j){
    for(int i=0;i<j;i++){
        printf(" ");
    }
}

// trocar o contador_RRN por c->proxRRNNo
// tratar o caso da raiz !!
PCPR no_inserir_recursivo(FILE *indice, NoArvore *atual, CPR valor_inserir, CabecalhoArvore *c, int level)
{
    printf("Inserção recursiva - Nível %d\n", level);
    PCPR inserir_restante = get_null_pcpr();

    if (atual == NULL) {  // Inicializa a árvore B com uma nova raiz
        printf("Criando nova raiz...\n");
        atual = no_criar(true, c->proxRRNno++);
        bcabecalho_setNoRaiz(c, atual->RRNdoNo);
        no_writebin(indice, atual);
    }

    if (atual->folha == FOLHA) {
        inserir_restante.corpo = valor_inserir;
    } else {
        // Busca a posição correta para inserção recursiva
        int idx_entrar = 0;
        for (int i = 0; i < atual->lotacao; i++) {
            if (valor_inserir.C > atual->CPRs[i].C) {
                idx_entrar = i + 1;
            }
        }
        NoArvore *no_filho = no_readbin(indice, atual->P[idx_entrar]);
        inserir_restante = no_inserir_recursivo(indice, no_filho, valor_inserir, c, level + 1);
    }

    if (PCPR_isnull(inserir_restante)) {
        return get_null_pcpr();  // Se nada precisa subir, retorna nulo
    }

    PCPR overflow = no_tenta_inserir(atual, inserir_restante.corpo, indice);
    if (PCPR_isnull(overflow)) {
        no_writebin(indice, atual);  // Escreve o nó atualizado no arquivo
        return get_null_pcpr();
    }

    // Split do nó atual
    int idx_meio = LOTACAO_MAX / 2;
    PCPR subiu;
    subiu.corpo = atual->CPRs[idx_meio];

    NoArvore *irmaozinho = no_criar(atual->folha, c->proxRRNno++);
    for (int i = idx_meio + 1, j = 0; i < LOTACAO_MAX; i++, j++) {
        irmaozinho->CPRs[j] = atual->CPRs[i];
        atual->CPRs[i].C = NULL_VALUE;
        atual->CPRs[i].PR = -1;
    }
    atual->lotacao = idx_meio;

    subiu.P = irmaozinho->RRNdoNo;

    no_writebin(indice, atual);
    no_writebin(indice, irmaozinho);

    if (c->noRaiz == atual->RRNdoNo) {
        NoArvore *nova_raiz = no_criar(false, c->proxRRNno++);
        nova_raiz->CPRs[0] = subiu.corpo;
        nova_raiz->P[0] = atual->RRNdoNo;
        nova_raiz->P[1] = irmaozinho->RRNdoNo;
        bcabecalho_setNoRaiz(c, nova_raiz->RRNdoNo);
        no_writebin(indice, nova_raiz);
    }

    return subiu;
}



int buscando_chave(FILE *arquivo, long int chave)
{
    NoArvore *no = no_criar(true, 0);
    NoArvore *raiz = no_criar(false, 0);
    Registro *registro = cria_registro();

    int rrn_dados;
    no = no_readbin(arquivo, 93);
    if(no == NULL || registro == NULL)
    {
        return -1;
    }

    while(!feof(arquivo)){
        
        //procura pela chave dentro da pagina
        int proximo_rrn = no->P[0]; // Adapte o índice conforme a chave a ser buscada
        for (int i = 0; i < no->nroChavesIndexadas; i++) {
            if (chave < no->CPRs[i].C) {
                proximo_rrn = no->P[i];
                break;
            }
            proximo_rrn = no->P[i + 1]; // Última comparação
        }
    }

    free(no);
    return rrn_dados;
}